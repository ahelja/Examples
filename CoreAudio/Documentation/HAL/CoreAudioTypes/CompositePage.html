<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html><style type="text/css"><!--a:link {text-decoration: none; font-family: Verdana, Geneva, Helvetica, Arial, sans-serif; font-size: small}a:visited {text-decoration: none; font-family: Verdana, Geneva, Helvetica, Arial, sans-serif; font-size: small}a:active {text-decoration: none; font-family: Verdana, Geneva, Helvetica, Arial, sans-serif; font-size: small}a:hover {text-decoration: underline; font-family: Verdana, Geneva, Helvetica, Arial, sans-serif; font-size: small}h4 {text-decoration: none; font-family: Verdana,Geneva,Arial,Helvetica,sans-serif; size: tiny; font-weight: bold}--></style><head>
    <title>CoreAudioTypes</title>
	 <meta name="generator" content="HeaderDoc">
</head><body bgcolor="#ffffff">
<h1><font face="Geneva,Arial,Helvtica">CoreAudioTypes</font></h1><br>
<h2>Discussion</h2>
This header defines the types and constants that all the CoreAudio APIs have in common.
<hr><br><h2>Functions</h2>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioChannelLayoutTag_GetNumberOfChannels">AudioChannelLayoutTag_GetNumberOfChannels</a></h2>
</td></tr></table><hr>A macro to get the number of channels out of an AudioChannelLayoutTag

<blockquote><pre><tt>#define AudioChannelLayoutTag_GetNumberOfChannels(layoutTag) ((UInt32)((layoutTag) & 0x0000FFFF))
</tt><br></pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>The low 16 bits of an AudioChannelLayoutTag gives the number of channels except
for kAudioChannelLayoutTag_UseChannelDescriptions and
kAudioChannelLayoutTag_UseChannelBitmap.
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>layoutTag</em></tt></dt><dd>The AudioChannelLayoutTag to examine.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>The number of channels the tag indicates.
</dd></dl>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="IsAudioFormatNativeEndian">IsAudioFormatNativeEndian</a></h2>
</td></tr></table><hr>A C++ inline function for checking if an ASBD indicates native endian linear PCM
data.

<blockquote><pre><tt>#if defined (
&nbsp;&nbsp;&nbsp;&nbsp;__cplusplus
)&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;inline bool IsAudioFormatNativeEndian(const AudioStreamBasicDescription& f
);
</tt><br>
</pre></blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Parameter Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt><em>f</em></tt></dt><dd>The AudioStreamBasicDescription to examine.</dd>
</dl>
</blockquote>
<dl><dt><i>function result</i></dt><dd>Whether or not the ASBD indicates native endian linear PCM data.
</dd></dl>
<h2>Typedefs</h2>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioChannelLabel">AudioChannelLabel</a></h2>
</td></tr></table><hr>A tag idenitfying how the channel is to be used.

<blockquote><pre>
typedef UInt32 AudioChannelLabel;
</pre>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioChannelLayoutTag">AudioChannelLayoutTag</a></h2>
</td></tr></table><hr>A tag identifying a particular pre-defined channel layout.

<blockquote><pre>
typedef UInt32 AudioChannelLayoutTag;
</pre>
</blockquote>
<h2>Structs</h2>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioBuffer">AudioBuffer</a></h2>
</td></tr></table><hr>A structure to hold a buffer of audio data.

<blockquote><pre>
struct AudioBuffer {
    UInt32  mNumberChannels;
    UInt32  mDataByteSize;
    void*   mData;
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mNumberChannels</tt></dt><dd>The number of interleaved channels in the buffer.</dd>
<dt><tt>mDataByteSize</tt></dt><dd>The number of bytes in the buffer pointed at by mData.</dd>
<dt><tt>mData</tt></dt><dd>A pointer to the buffer of audio data.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioBufferList">AudioBufferList</a></h2>
</td></tr></table><hr>A variable length array of AudioBuffer structures.

<blockquote><pre>
struct AudioBufferList {
    UInt32      mNumberBuffers;
    AudioBuffer mBuffers[kVariableLengthArray];
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mNumberBuffers</tt></dt><dd>The number of AudioBuffers in the mBuffers array.</dd>
<dt><tt>mBuffers</tt></dt><dd>A variable length array of AudioBuffers.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioChannelDescription">AudioChannelDescription</a></h2>
</td></tr></table><hr>This structure describes a single channel.

<blockquote><pre>
struct AudioChannelDescription {
    AudioChannelLabel   mChannelLabel;
    UInt32              mChannelFlags;
    Float32             mCoordinates[3];
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mChannelLabel</tt></dt><dd>The AudioChannelLabel that describes the channel.</dd>
<dt><tt>mChannelFlags</tt></dt><dd>Flags that control the interpretation of mCoordinates.</dd>
<dt><tt>mCoordinates</tt></dt><dd>An ordered triple that specifies a precise speaker location.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioChannelLayout">AudioChannelLayout</a></h2>
</td></tr></table><hr>This structure is used to specify channel layouts in files and hardware.

<blockquote><pre>
struct AudioChannelLayout {
    AudioChannelLayoutTag       mChannelLayoutTag;
    UInt32                      mChannelBitmap;
    UInt32                      mNumberChannelDescriptions;
    AudioChannelDescription     mChannelDescriptions[kVariableLengthArray];
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mChannelLayoutTag</tt></dt><dd>The AudioChannelLayoutTag that indicates the layout.</dd>
<dt><tt>mChannelBitmap</tt></dt><dd>If mChannelLayoutTag is set to kAudioChannelLayoutTag_UseChannelBitmap, this
field is the channel usage bitmap.</dd>
<dt><tt>mNumberChannelDescriptions</tt></dt><dd>The number of items in the mChannelDescriptions array.</dd>
<dt><tt>mChannelDescriptions</tt></dt><dd>A variable length array of AudioChannelDescriptions that describe the
layout.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioClassDescription">AudioClassDescription</a></h2>
</td></tr></table><hr>This structure is used to describe codecs installed on the system.

<blockquote><pre>
struct AudioClassDescription {
    OSType  mType;
    OSType  mSubType;
    OSType  mManufacturer;
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mType</tt></dt><dd>The four char code codec type.</dd>
<dt><tt>mSubType</tt></dt><dd>The four char code codec subtype.</dd>
<dt><tt>mManufacturer</tt></dt><dd>The four char code codec manufacturer.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioStreamBasicDescription">AudioStreamBasicDescription</a></h2>
</td></tr></table><hr>This structure encapsulates all the information for describing the basic
format properties of a stream of audio data.

<blockquote><pre>
struct AudioStreamBasicDescription {
    Float64 mSampleRate;
    UInt32  mFormatID;
    UInt32  mFormatFlags;
    UInt32  mBytesPerPacket;
    UInt32  mFramesPerPacket;
    UInt32  mBytesPerFrame;
    UInt32  mChannelsPerFrame;
    UInt32  mBitsPerChannel;
    UInt32  mReserved;
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>This structure is sufficient to describe any constant bit rate format that  has
channels that are the same size. Extensions are required for variable bit rate
data and for constant bit rate data where the channels have unequal sizes.
However, where applicable, the appropriate fields will be filled out correctly
for these kinds of formats (the extra data is provided via separate properties).
In all fields, a value of 0 indicates that the field is either unknown, not
applicable or otherwise is inapproprate for the format and should be ignored.
Note that 0 is still a valid value for most formats in the mFormatFlags field.
<br><br>
In audio data a frame is one sample across all channels. In non-interleaved
audio, the per frame fields identify one channel. In interleaved audio, the per
frame fields identify the set of n channels. In uncompressed audio, a Packet is
one frame, (mFramesPerPacket == 1). In compressed audio, a Packet is an
indivisible chunk of compressed data, for example an AAC packet will contain
1024 sample frames.
</p>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mSampleRate</tt></dt><dd>The number of sample frames per second of the data in the stream.</dd>
<dt><tt>mFormatID</tt></dt><dd>A four char code indicating the general kind of data in the stream.</dd>
<dt><tt>mFormatFlags</tt></dt><dd>Flags specific to each format.</dd>
<dt><tt>mBytesPerPacket</tt></dt><dd>The number of bytes in a packet of data.</dd>
<dt><tt>mFramesPerPacket</tt></dt><dd>The number of sample frames in each packet of data.</dd>
<dt><tt>mBytesPerFrame</tt></dt><dd>The number of bytes in a single sample frame of data.</dd>
<dt><tt>mChannelsPerFrame</tt></dt><dd>The number of channels in each frame of data.</dd>
<dt><tt>mBitsPerChannel</tt></dt><dd>The number of bits of sample data for each channel in a frame of data.</dd>
<dt><tt>mReserved</tt></dt><dd>Pads the structure out to force an even 8 byte alignment.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioStreamPacketDescription">AudioStreamPacketDescription</a></h2>
</td></tr></table><hr>This structure describes the packet layout of a buffer of data where the size of
each packet may not be the same or where there is extraneous data between
packets.

<blockquote><pre>
struct  AudioStreamPacketDescription {
    SInt64  mStartOffset;
    UInt32  mVariableFramesInPacket;
    UInt32  mDataByteSize;
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mStartOffset</tt></dt><dd>The number of bytes from the start of the buffer to the beginning of the
packet.</dd>
<dt><tt>mVariableFramesInPacket</tt></dt><dd>The number of sample frames of data in the packet. For formats with a
constant number of frames per packet, this field is set to 0.</dd>
<dt><tt>mDataByteSize</tt></dt><dd>The number of bytes in the packet.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioTimeStamp">AudioTimeStamp</a></h2>
</td></tr></table><hr>A strucutre that holds different representations of the same point in time.

<blockquote><pre>
struct AudioTimeStamp {
    Float64         mSampleTime;
    UInt64          mHostTime;
    Float64         mRateScalar;
    UInt64          mWordClockTime;
    SMPTETime       mSMPTETime;
    UInt32          mFlags;
    UInt32          mReserved;
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mSampleTime</tt></dt><dd>The absolute sample frame time.</dd>
<dt><tt>mHostTime</tt></dt><dd>The host machine's time base (see <CoreAudio/HostTime.h>).</dd>
<dt><tt>mRateScalar</tt></dt><dd>The ratio of actual host ticks per sample frame to the nominal host ticks
per sample frame.</dd>
<dt><tt>mWordClockTime</tt></dt><dd>The word clock time.</dd>
<dt><tt>mSMPTETime</tt></dt><dd>The SMPTE time.</dd>
<dt><tt>mFlags</tt></dt><dd>A set of flags indicating which representations of the time are valid.</dd>
<dt><tt>mReserved</tt></dt><dd>Pads the structure out to force an even 8 byte alignment.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioValueRange">AudioValueRange</a></h2>
</td></tr></table><hr>This structure holds a pair of numbers that represent a continuous range of
values.

<blockquote><pre>
struct AudioValueRange {
    Float64 mMinimum;
    Float64 mMaximum;
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mMinimum</tt></dt><dd>The minimum value.</dd>
<dt><tt>mMaximum</tt></dt><dd>The maximum value.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioValueTranslation">AudioValueTranslation</a></h2>
</td></tr></table><hr>This stucture holds the buffers necessary for translation operations.

<blockquote><pre>
struct AudioValueTranslation {
    void*   mInputData;
    UInt32  mInputDataSize;
    void*   mOutputData;
    UInt32  mOutputDataSize;
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mInputData</tt></dt><dd>The buffer containing the data to be translated.</dd>
<dt><tt>mInputDataSize</tt></dt><dd>The number of bytes in the buffer pointed at by mInputData.</dd>
<dt><tt>mOutputData</tt></dt><dd>The buffer to hold the result of the translation.</dd>
<dt><tt>mOutputDataSize</tt></dt><dd>The number of bytes in the buffer pointed at by mOutputData.</dd>
</dl>
</blockquote>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="SMPTETime">SMPTETime</a></h2>
</td></tr></table><hr>A structure for holding a SMPTE time.

<blockquote><pre>
struct SMPTETime {
    SInt16  mSubframes;
    SInt16  mSubframeDivisor;
    UInt32  mCounter;
    UInt32  mType;
    UInt32  mFlags;
    SInt16  mHours;
    SInt16  mMinutes;
    SInt16  mSeconds;
    SInt16  mFrames;
} ;
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Field Descriptions</font></h5>
<blockquote>
<dl>
<dt><tt>mSubframes</tt></dt><dd>The number of subframes in the full message.</dd>
<dt><tt>mSubframeDivisor</tt></dt><dd>The number of subframes per frame (typically 80).</dd>
<dt><tt>mCounter</tt></dt><dd>The total number of messages received.</dd>
<dt><tt>mType</tt></dt><dd>The kind of SMPTE time using the SMPTE time type constants.</dd>
<dt><tt>mFlags</tt></dt><dd>A set of flags that indicate the SMPTE state.</dd>
<dt><tt>mHours</tt></dt><dd>The number of hourse in the full message.</dd>
<dt><tt>mMinutes</tt></dt><dd>The number of minutes in the full message.</dd>
<dt><tt>mSeconds</tt></dt><dd>The number of seconds in the full message.</dd>
<dt><tt>mFrames</tt></dt><dd>The number of frames in the full message.</dd>
</dl>
</blockquote>
<h2>Enumerations</h2>
<hr><a name="//apple_ref/c/tag/AudioChannelLabel Constants"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioChannelLabel Constants">AudioChannelLabel Constants</a></h2>
</td></tr></table><hr>These constants are for use in the mChannelLabel field of an
AudioChannelDescription structure.
<br>
<blockquote><pre>
enum
{
    kAudioChannelLabel_Unknown                  = 0xFFFFFFFF,   // unknown or unspecified other use
    kAudioChannelLabel_Unused                   = 0,            // channel is present, but has no intended use or destination
    kAudioChannelLabel_UseCoordinates           = 100,          // channel is described by the mCoordinates fields.

    kAudioChannelLabel_Left                     = 1,
    kAudioChannelLabel_Right                    = 2,
    kAudioChannelLabel_Center                   = 3,
    kAudioChannelLabel_LFEScreen                = 4,
    kAudioChannelLabel_LeftSurround             = 5,            // WAVE: "Back Left"
    kAudioChannelLabel_RightSurround            = 6,            // WAVE: "Back Right"
    kAudioChannelLabel_LeftCenter               = 7,
    kAudioChannelLabel_RightCenter              = 8,
    kAudioChannelLabel_CenterSurround           = 9,            // WAVE: "Back Center" or plain "Rear Surround"
    kAudioChannelLabel_LeftSurroundDirect       = 10,           // WAVE: "Side Left"
    kAudioChannelLabel_RightSurroundDirect      = 11,           // WAVE: "Side Right"
    kAudioChannelLabel_TopCenterSurround        = 12,
    kAudioChannelLabel_VerticalHeightLeft       = 13,           // WAVE: "Top Front Left"
    kAudioChannelLabel_VerticalHeightCenter     = 14,           // WAVE: "Top Front Center"
    kAudioChannelLabel_VerticalHeightRight      = 15,           // WAVE: "Top Front Right"

    kAudioChannelLabel_TopBackLeft              = 16,
    kAudioChannelLabel_TopBackCenter            = 17,
    kAudioChannelLabel_TopBackRight             = 18,

    kAudioChannelLabel_RearSurroundLeft         = 33,
    kAudioChannelLabel_RearSurroundRight        = 34,
    kAudioChannelLabel_LeftWide                 = 35,
    kAudioChannelLabel_RightWide                = 36,
    kAudioChannelLabel_LFE2                     = 37,
    kAudioChannelLabel_LeftTotal                = 38,           // matrix encoded 4 channels
    kAudioChannelLabel_RightTotal               = 39,           // matrix encoded 4 channels
    kAudioChannelLabel_HearingImpaired          = 40,
    kAudioChannelLabel_Narration                = 41,
    kAudioChannelLabel_Mono                     = 42,
    kAudioChannelLabel_DialogCentricMix         = 43,

    kAudioChannelLabel_CenterSurroundDirect     = 44,           // back center, non diffuse

    // first order ambisonic channels
    kAudioChannelLabel_Ambisonic_W              = 200,
    kAudioChannelLabel_Ambisonic_X              = 201,
    kAudioChannelLabel_Ambisonic_Y              = 202,
    kAudioChannelLabel_Ambisonic_Z              = 203,

    // Mid/Side Recording
    kAudioChannelLabel_MS_Mid                   = 204,
    kAudioChannelLabel_MS_Side                  = 205,

    // X-Y Recording
    kAudioChannelLabel_XY_X                     = 206,
    kAudioChannelLabel_XY_Y                     = 207,

    // other
    kAudioChannelLabel_HeadphonesLeft           = 301,
    kAudioChannelLabel_HeadphonesRight          = 302,
    kAudioChannelLabel_ClickTrack               = 304,
    kAudioChannelLabel_ForeignLanguage          = 305,

    // generic discrete channel
    kAudioChannelLabel_Discrete                 = 400,

    // numbered discrete channel
    kAudioChannelLabel_Discrete_0               = (1L&lt;&lt;16) | 0,
    kAudioChannelLabel_Discrete_1               = (1L&lt;&lt;16) | 1,
    kAudioChannelLabel_Discrete_2               = (1L&lt;&lt;16) | 2,
    kAudioChannelLabel_Discrete_3               = (1L&lt;&lt;16) | 3,
    kAudioChannelLabel_Discrete_4               = (1L&lt;&lt;16) | 4,
    kAudioChannelLabel_Discrete_5               = (1L&lt;&lt;16) | 5,
    kAudioChannelLabel_Discrete_6               = (1L&lt;&lt;16) | 6,
    kAudioChannelLabel_Discrete_7               = (1L&lt;&lt;16) | 7,
    kAudioChannelLabel_Discrete_8               = (1L&lt;&lt;16) | 8,
    kAudioChannelLabel_Discrete_9               = (1L&lt;&lt;16) | 9,
    kAudioChannelLabel_Discrete_10              = (1L&lt;&lt;16) | 10,
    kAudioChannelLabel_Discrete_11              = (1L&lt;&lt;16) | 11,
    kAudioChannelLabel_Discrete_12              = (1L&lt;&lt;16) | 12,
    kAudioChannelLabel_Discrete_13              = (1L&lt;&lt;16) | 13,
    kAudioChannelLabel_Discrete_14              = (1L&lt;&lt;16) | 14,
    kAudioChannelLabel_Discrete_15              = (1L&lt;&lt;16) | 15,
    kAudioChannelLabel_Discrete_65535           = (1L&lt;&lt;16) | 65535
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>These channel labels attempt to list all labels in common use. Due to the
ambiguities in channel labeling by various groups, there may be some overlap or
duplication in the labels below. Use the label which most clearly describes what
you mean.
<br><br>
WAVE files seem to follow the USB spec for the channel flags. A channel map lets
you put these channels in any order, however a WAVE file only supports labels
1-18 and if present, they must be in the order given below. The integer values
for the labels below match the bit position of the label in the USB bitmap and
thus also the WAVE file bitmap.
</p>
<hr><a name="//apple_ref/c/tag/AudioChannelLayoutTag"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioChannelLayoutTag">AudioChannelLayoutTag</a></h2>
</td></tr></table><hr>These constants are used in the mChannelLayoutTag field of an AudioChannelLayout
structure.
<br>
<blockquote><pre>
enum
{
    // Some channel abbreviations used below:
    // L - left
    // R - right
    // C - center
    // Ls - left surround
    // Rs - right surround
    // Cs - center surround
    // Rls - rear left surround
    // Rrs - rear right surround
    // Lw - left wide
    // Rw - right wide
    // Lsd - left surround direct
    // Rsd - right surround direct
    // Lc - left center
    // Rc - right center
    // Ts - top surround
    // Vhl - vertical height left
    // Vhc - vertical height center
    // Vhr - vertical height right
    // Lt - left matrix total. for matrix encoded stereo.
    // Rt - right matrix total. for matrix encoded stereo.

    //  General layouts
    kAudioChannelLayoutTag_UseChannelDescriptions   = (0L&lt;&lt;16) | 0,     // use the array of AudioChannelDescriptions to define the mapping.
    kAudioChannelLayoutTag_UseChannelBitmap         = (1L&lt;&lt;16) | 0,     // use the bitmap to define the mapping.

    kAudioChannelLayoutTag_Mono                     = (100L&lt;&lt;16) | 1,   // a standard mono stream
    kAudioChannelLayoutTag_Stereo                   = (101L&lt;&lt;16) | 2,   // a standard stereo stream (L R) - implied playback
    kAudioChannelLayoutTag_StereoHeadphones         = (102L&lt;&lt;16) | 2,   // a standard stereo stream (L R) - implied headphone playbac
    kAudioChannelLayoutTag_MatrixStereo             = (103L&lt;&lt;16) | 2,   // a matrix encoded stereo stream (Lt, Rt)
    kAudioChannelLayoutTag_MidSide                  = (104L&lt;&lt;16) | 2,   // mid/side recording
    kAudioChannelLayoutTag_XY                       = (105L&lt;&lt;16) | 2,   // coincident mic pair (often 2 figure 8's)
    kAudioChannelLayoutTag_Binaural                 = (106L&lt;&lt;16) | 2,   // binaural stereo (left, right)
    kAudioChannelLayoutTag_Ambisonic_B_Format       = (107L&lt;&lt;16) | 4,   // W, X, Y, Z

    kAudioChannelLayoutTag_Quadraphonic             = (108L&lt;&lt;16) | 4,   // front left, front right, back left, back right

    kAudioChannelLayoutTag_Pentagonal               = (109L&lt;&lt;16) | 5,   // left, right, rear left, rear right, center

    kAudioChannelLayoutTag_Hexagonal                = (110L&lt;&lt;16) | 6,   // left, right, rear left, rear right, center, rear

    kAudioChannelLayoutTag_Octagonal                = (111L&lt;&lt;16) | 8,   // front left, front right, rear left, rear right,
                                                                        // front center, rear center, side left, side right

    kAudioChannelLayoutTag_Cube                     = (112L&lt;&lt;16) | 8,   // left, right, rear left, rear right
                                                                        // top left, top right, top rear left, top rear right

    //  MPEG defined layouts
    kAudioChannelLayoutTag_MPEG_1_0                 = kAudioChannelLayoutTag_Mono,          //  C
    kAudioChannelLayoutTag_MPEG_2_0                 = kAudioChannelLayoutTag_Stereo,        //  L R
    kAudioChannelLayoutTag_MPEG_3_0_A               = (113L&lt;&lt;16) | 3,                       //  L R C
    kAudioChannelLayoutTag_MPEG_3_0_B               = (114L&lt;&lt;16) | 3,                       //  C L R
    kAudioChannelLayoutTag_MPEG_4_0_A               = (115L&lt;&lt;16) | 4,                       //  L R C Cs
    kAudioChannelLayoutTag_MPEG_4_0_B               = (116L&lt;&lt;16) | 4,                       //  C L R Cs
    kAudioChannelLayoutTag_MPEG_5_0_A               = (117L&lt;&lt;16) | 5,                       //  L R C Ls Rs
    kAudioChannelLayoutTag_MPEG_5_0_B               = (118L&lt;&lt;16) | 5,                       //  L R Ls Rs C
    kAudioChannelLayoutTag_MPEG_5_0_C               = (119L&lt;&lt;16) | 5,                       //  L C R Ls Rs
    kAudioChannelLayoutTag_MPEG_5_0_D               = (120L&lt;&lt;16) | 5,                       //  C L R Ls Rs
    kAudioChannelLayoutTag_MPEG_5_1_A               = (121L&lt;&lt;16) | 6,                       //  L R C LFE Ls Rs
    kAudioChannelLayoutTag_MPEG_5_1_B               = (122L&lt;&lt;16) | 6,                       //  L R Ls Rs C LFE
    kAudioChannelLayoutTag_MPEG_5_1_C               = (123L&lt;&lt;16) | 6,                       //  L C R Ls Rs LFE
    kAudioChannelLayoutTag_MPEG_5_1_D               = (124L&lt;&lt;16) | 6,                       //  C L R Ls Rs LFE
    kAudioChannelLayoutTag_MPEG_6_1_A               = (125L&lt;&lt;16) | 7,                       //  L R C LFE Ls Rs Cs
    kAudioChannelLayoutTag_MPEG_7_1_A               = (126L&lt;&lt;16) | 8,                       //  L R C LFE Ls Rs Lc Rc
    kAudioChannelLayoutTag_MPEG_7_1_B               = (127L&lt;&lt;16) | 8,                       //  C Lc Rc L R Ls Rs LFE    (doc: IS-13818-7 MPEG2-AAC Table 3.1)
    kAudioChannelLayoutTag_MPEG_7_1_C               = (128L&lt;&lt;16) | 8,                       //  L R C LFE Ls R Rls Rrs
    kAudioChannelLayoutTag_Emagic_Default_7_1       = (129L&lt;&lt;16) | 8,                       //  L R Ls Rs C LFE Lc Rc
    kAudioChannelLayoutTag_SMPTE_DTV                = (130L&lt;&lt;16) | 8,                       //  L R C LFE Ls Rs Lt Rt
                                                                                            //      (kAudioChannelLayoutTag_ITU_5_1 plus a matrix encoded stereo mix)

    //  ITU defined layouts
    kAudioChannelLayoutTag_ITU_1_0                  = kAudioChannelLayoutTag_Mono,          //  C
    kAudioChannelLayoutTag_ITU_2_0                  = kAudioChannelLayoutTag_Stereo,        //  L R

    kAudioChannelLayoutTag_ITU_2_1                  = (131L&lt;&lt;16) | 3,                       //  L R Cs
    kAudioChannelLayoutTag_ITU_2_2                  = (132L&lt;&lt;16) | 4,                       //  L R Ls Rs
    kAudioChannelLayoutTag_ITU_3_0                  = kAudioChannelLayoutTag_MPEG_3_0_A,    //  L R C
    kAudioChannelLayoutTag_ITU_3_1                  = kAudioChannelLayoutTag_MPEG_4_0_A,    //  L R C Cs

    kAudioChannelLayoutTag_ITU_3_2                  = kAudioChannelLayoutTag_MPEG_5_0_A,    //  L R C Ls Rs
    kAudioChannelLayoutTag_ITU_3_2_1                = kAudioChannelLayoutTag_MPEG_5_1_A,    //  L R C LFE Ls Rs
    kAudioChannelLayoutTag_ITU_3_4_1                = kAudioChannelLayoutTag_MPEG_7_1_C,    //  L R C LFE Ls Rs Rls Rrs

    // DVD defined layouts
    kAudioChannelLayoutTag_DVD_0                    = kAudioChannelLayoutTag_Mono,          // C (mono)
    kAudioChannelLayoutTag_DVD_1                    = kAudioChannelLayoutTag_Stereo,        // L R
    kAudioChannelLayoutTag_DVD_2                    = kAudioChannelLayoutTag_ITU_2_1,       // L R Cs
    kAudioChannelLayoutTag_DVD_3                    = kAudioChannelLayoutTag_ITU_2_2,       // L R Ls Rs
    kAudioChannelLayoutTag_DVD_4                    = (133L&lt;&lt;16) | 3,                       // L R LFE
    kAudioChannelLayoutTag_DVD_5                    = (134L&lt;&lt;16) | 4,                       // L R LFE Cs
    kAudioChannelLayoutTag_DVD_6                    = (135L&lt;&lt;16) | 5,                       // L R LFE Ls Rs
    kAudioChannelLayoutTag_DVD_7                    = kAudioChannelLayoutTag_MPEG_3_0_A,    // L R C
    kAudioChannelLayoutTag_DVD_8                    = kAudioChannelLayoutTag_MPEG_4_0_A,    // L R C Cs
    kAudioChannelLayoutTag_DVD_9                    = kAudioChannelLayoutTag_MPEG_5_0_A,    // L R C Ls Rs
    kAudioChannelLayoutTag_DVD_10                   = (136L&lt;&lt;16) | 4,                       // L R C LFE
    kAudioChannelLayoutTag_DVD_11                   = (137L&lt;&lt;16) | 5,                       // L R C LFE Cs
    kAudioChannelLayoutTag_DVD_12                   = kAudioChannelLayoutTag_MPEG_5_1_A,    // L R C LFE Ls Rs
    // 13 through 17 are duplicates of 8 through 12.
    kAudioChannelLayoutTag_DVD_13                   = kAudioChannelLayoutTag_DVD_8,         // L R C Cs
    kAudioChannelLayoutTag_DVD_14                   = kAudioChannelLayoutTag_DVD_9,         // L R C Ls Rs
    kAudioChannelLayoutTag_DVD_15                   = kAudioChannelLayoutTag_DVD_10,        // L R C LFE
    kAudioChannelLayoutTag_DVD_16                   = kAudioChannelLayoutTag_DVD_11,        // L R C LFE Cs
    kAudioChannelLayoutTag_DVD_17                   = kAudioChannelLayoutTag_DVD_12,        // L R C LFE Ls Rs
    kAudioChannelLayoutTag_DVD_18                   = (138L&lt;&lt;16) | 5,                       // L R Ls Rs LFE
    kAudioChannelLayoutTag_DVD_19                   = kAudioChannelLayoutTag_MPEG_5_0_B,    // L R Ls Rs C
    kAudioChannelLayoutTag_DVD_20                   = kAudioChannelLayoutTag_MPEG_5_1_B,    // L R Ls Rs C LFE

    // These layouts are recommended for AudioUnit usage
        // These are the symmetrical layouts
    kAudioChannelLayoutTag_AudioUnit_4              = kAudioChannelLayoutTag_Quadraphonic,
    kAudioChannelLayoutTag_AudioUnit_5              = kAudioChannelLayoutTag_Pentagonal,
    kAudioChannelLayoutTag_AudioUnit_6              = kAudioChannelLayoutTag_Hexagonal,
    kAudioChannelLayoutTag_AudioUnit_8              = kAudioChannelLayoutTag_Octagonal,
        // These are the surround-based layouts
    kAudioChannelLayoutTag_AudioUnit_5_0            = kAudioChannelLayoutTag_MPEG_5_0_B,    // L R Ls Rs C
    kAudioChannelLayoutTag_AudioUnit_6_0            = (139L&lt;&lt;16) | 6,                       // L R Ls Rs C Cs
    kAudioChannelLayoutTag_AudioUnit_7_0            = (140L&lt;&lt;16) | 7,                       // L R Ls Rs C Rls Rrs
    kAudioChannelLayoutTag_AudioUnit_5_1            = kAudioChannelLayoutTag_MPEG_5_1_A,    // L R C LFE Ls Rs
    kAudioChannelLayoutTag_AudioUnit_6_1            = kAudioChannelLayoutTag_MPEG_6_1_A,    // L R C LFE Ls Rs Cs
    kAudioChannelLayoutTag_AudioUnit_7_1            = kAudioChannelLayoutTag_MPEG_7_1_C,    // L R C LFE Ls Rs Rls Rrs

    kAudioChannelLayoutTag_AAC_Quadraphonic         = kAudioChannelLayoutTag_Quadraphonic,  // L R Ls Rs
    kAudioChannelLayoutTag_AAC_4_0                  = kAudioChannelLayoutTag_MPEG_4_0_B,    // C L R Cs
    kAudioChannelLayoutTag_AAC_5_0                  = kAudioChannelLayoutTag_MPEG_5_0_D,    // C L R Ls Rs
    kAudioChannelLayoutTag_AAC_5_1                  = kAudioChannelLayoutTag_MPEG_5_1_D,    // C L R Ls Rs Lfe
    kAudioChannelLayoutTag_AAC_6_0                  = (141L&lt;&lt;16) | 6,                       // C L R Ls Rs Cs
    kAudioChannelLayoutTag_AAC_6_1                  = (142L&lt;&lt;16) | 7,                       // C L R Ls Rs Cs Lfe
    kAudioChannelLayoutTag_AAC_7_0                  = (143L&lt;&lt;16) | 7,                       // C L R Ls Rs Rls Rrs
    kAudioChannelLayoutTag_AAC_7_1                  = kAudioChannelLayoutTag_MPEG_7_1_B,    // C Lc Rc L R Ls Rs Lfe
    kAudioChannelLayoutTag_AAC_Octagonal            = (144L&lt;&lt;16) | 8,                       // C L R Ls Rs Rls Rrs Cs

    kAudioChannelLayoutTag_TMH_10_2_std             = (145L&lt;&lt;16) | 16,                      // L R C Vhc Lsd Rsd Ls Rs Vhl Vhr Lw Rw Csd Cs LFE1 LFE2
    kAudioChannelLayoutTag_TMH_10_2_full            = (146L&lt;&lt;16) | 21,                       // TMH_10_2_std plus: Lc Rc HI VI Haptic

  kAudioChannelLayoutTag_DiscreteInOrder      = (147L&lt;&lt;16) | 0            // needs to be ORed with the actual number of channels  
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Constants
</p>
<hr><a name="//apple_ref/c/tag/AudioStreamBasicDescription"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioStreamBasicDescription">AudioStreamBasicDescription</a></h2>
</td></tr></table><hr>Constants for use with AudioStreamBasicDescription
<br>
<blockquote><pre>
enum
{
    kAudioStreamAnyRate = 0
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Constants
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kAudioStreamAnyRate"><tt>kAudioStreamAnyRate</tt></a></dt><dd>The format can use any sample rate. Note that this constant can only appear
in listings of supported formats. It will never appear in a current format.</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/AudioTimeStamp"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="AudioTimeStamp">AudioTimeStamp</a></h2>
</td></tr></table><hr>The flags that indicate which fields in an AudioTimeStamp structure are valid.
<br>
<blockquote><pre>
enum
{
    kAudioTimeStampSampleTimeValid      = (1L &lt;&lt; 0),
    kAudioTimeStampHostTimeValid        = (1L &lt;&lt; 1),
    kAudioTimeStampRateScalarValid      = (1L &lt;&lt; 2),
    kAudioTimeStampWordClockTimeValid   = (1L &lt;&lt; 3),
    kAudioTimeStampSMPTETimeValid       = (1L &lt;&lt; 4)
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Flags
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kAudioTimeStampSampleTimeValid"><tt>kAudioTimeStampSampleTimeValid</tt></a></dt><dd>The sample frame time is valid.</dd>
<dt><a name="//apple_ref/c/econst/kAudioTimeStampHostTimeValid"><tt>kAudioTimeStampHostTimeValid</tt></a></dt><dd>The host time is valid.</dd>
<dt><a name="//apple_ref/c/econst/kAudioTimeStampRateScalarValid"><tt>kAudioTimeStampRateScalarValid</tt></a></dt><dd>The rate scalar is valid.</dd>
<dt><a name="//apple_ref/c/econst/kAudioTimeStampWordClockTimeValid"><tt>kAudioTimeStampWordClockTimeValid</tt></a></dt><dd>The word clock time is valid.</dd>
<dt><a name="//apple_ref/c/econst/kAudioTimeStampSMPTETimeValid"><tt>kAudioTimeStampSMPTETimeValid</tt></a></dt><dd>The SMPTE time is valid.</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/Channel"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Channel">Channel</a></h2>
</td></tr></table><hr>These constants are for use in the mChannelBitmap field of an
AudioChannelLayout structure.
<br>
<blockquote><pre>
enum
{
    kAudioChannelBit_Left                       = (1L&lt;&lt;0),
    kAudioChannelBit_Right                      = (1L&lt;&lt;1),
    kAudioChannelBit_Center                     = (1L&lt;&lt;2),
    kAudioChannelBit_LFEScreen                  = (1L&lt;&lt;3),
    kAudioChannelBit_LeftSurround               = (1L&lt;&lt;4),      // WAVE: "Back Left"
    kAudioChannelBit_RightSurround              = (1L&lt;&lt;5),      // WAVE: "Back Right"
    kAudioChannelBit_LeftCenter                 = (1L&lt;&lt;6),
    kAudioChannelBit_RightCenter                = (1L&lt;&lt;7),
    kAudioChannelBit_CenterSurround             = (1L&lt;&lt;8),      // WAVE: "Back Center"
    kAudioChannelBit_LeftSurroundDirect         = (1L&lt;&lt;9),      // WAVE: "Side Left"
    kAudioChannelBit_RightSurroundDirect        = (1L&lt;&lt;10),     // WAVE: "Side Right"
    kAudioChannelBit_TopCenterSurround          = (1L&lt;&lt;11),
    kAudioChannelBit_VerticalHeightLeft         = (1L&lt;&lt;12),     // WAVE: "Top Front Left"
    kAudioChannelBit_VerticalHeightCenter       = (1L&lt;&lt;13),     // WAVE: "Top Front Center"
    kAudioChannelBit_VerticalHeightRight        = (1L&lt;&lt;14),     // WAVE: "Top Front Right"
    kAudioChannelBit_TopBackLeft                = (1L&lt;&lt;15),
    kAudioChannelBit_TopBackCenter              = (1L&lt;&lt;16),
    kAudioChannelBit_TopBackRight               = (1L&lt;&lt;17)
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Bitmap Constants
</p>
<hr><a name="//apple_ref/c/tag/Channel"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Channel">Channel</a></h2>
</td></tr></table><hr>These constants are used in the mChannelFlags field of an
AudioChannelDescription structure.
<br>
<blockquote><pre>
enum
{
  kAudioChannelFlags_AllOff          = 0,
    kAudioChannelFlags_RectangularCoordinates   = (1L&lt;&lt;0),
    kAudioChannelFlags_SphericalCoordinates     = (1L&lt;&lt;1),
    kAudioChannelFlags_Meters                   = (1L&lt;&lt;2)
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Coordinate Flags
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kAudioChannelFlags_RectangularCoordinates"><tt>kAudioChannelFlags_RectangularCoordinates</tt></a></dt><dd>The channel is specified by the cartesioan coordinates of the speaker
position. This flag is mutally exclusive with
kAudioChannelFlags_SphericalCoordinates.</dd>
<dt><a name="//apple_ref/c/econst/kAudioChannelFlags_SphericalCoordinates"><tt>kAudioChannelFlags_SphericalCoordinates</tt></a></dt><dd>The channel is specified by the spherical coordinates of the speaker
position. This flag is mutally exclusive with
kAudioChannelFlags_RectangularCoordinates.</dd>
<dt><a name="//apple_ref/c/econst/kAudioChannelFlags_Meters"><tt>kAudioChannelFlags_Meters</tt></a></dt><dd>Set to indicate the units are in meters, clear to indicate the units are
relative to the unit cube or unit sphere.</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/Channel"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Channel">Channel</a></h2>
</td></tr></table><hr>Constants for indexing the mCoordinates array in an AudioChannelDescription
structure.
<br>
<blockquote><pre>
enum
{
    kAudioChannelCoordinates_LeftRight  = 0,
    kAudioChannelCoordinates_BackFront  = 1,
    kAudioChannelCoordinates_DownUp     = 2,
    kAudioChannelCoordinates_Azimuth    = 0,
    kAudioChannelCoordinates_Elevation  = 1,
    kAudioChannelCoordinates_Distance   = 2
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Coordinate Index Constants
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kAudioChannelCoordinates_LeftRight"><tt>kAudioChannelCoordinates_LeftRight</tt></a></dt><dd>For rectangulare coordinates, negative is left and positive is right.</dd>
<dt><a name="//apple_ref/c/econst/kAudioChannelCoordinates_BackFront"><tt>kAudioChannelCoordinates_BackFront</tt></a></dt><dd>For rectangulare coordinates, negative is back and positive is front.</dd>
<dt><a name="//apple_ref/c/econst/kAudioChannelCoordinates_DownUp"><tt>kAudioChannelCoordinates_DownUp</tt></a></dt><dd>For rectangulare coordinates, negative is below ground level, 0 is ground
level, and positive is above ground level.</dd>
<dt><a name="//apple_ref/c/econst/kAudioChannelCoordinates_Azimuth"><tt>kAudioChannelCoordinates_Azimuth</tt></a></dt><dd>For spherical coordinates, 0 is front center, positive is right, negative is
left. This is measured in degrees.</dd>
<dt><a name="//apple_ref/c/econst/kAudioChannelCoordinates_Elevation"><tt>kAudioChannelCoordinates_Elevation</tt></a></dt><dd>For spherical coordinates, +90 is zenith, 0 is horizontal, -90 is nadir.
This is measured in degrees.</dd>
<dt><a name="//apple_ref/c/econst/kAudioChannelCoordinates_Distance"><tt>kAudioChannelCoordinates_Distance</tt></a></dt><dd>For spherical coordinates, the units are described by flags.</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/Commonly"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Commonly">Commonly</a></h2>
</td></tr></table><hr>Some commonly used combinations of flags for AudioStreamBasicDescriptions.
<br>
<blockquote><pre>
enum
{
#if TARGET_RT_BIG_ENDIAN
    kAudioFormatFlagsNativeEndian       = kAudioFormatFlagIsBigEndian,
#else
    kAudioFormatFlagsNativeEndian       = 0,
#endif
    kAudioFormatFlagsNativeFloatPacked  = kAudioFormatFlagIsFloat | kAudioFormatFlagsNativeEndian | kAudioFormatFlagIsPacked
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Used Combinations of ASBD Flags
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagsNativeEndian"><tt>kAudioFormatFlagsNativeEndian</tt></a></dt><dd>Defined to set or clear kAudioFormatFlagIsBigEndian depending on the
endianness of the processor at build time.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagsNativeFloatPacked"><tt>kAudioFormatFlagsNativeFloatPacked</tt></a></dt><dd>The flags for the canonical format of fully packed, native endian floating
point data.</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/Commonly"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Commonly">Commonly</a></h2>
</td></tr></table><hr>Some commonly used combinations of AudioTimeStamp flags.
<br>
<blockquote><pre>
enum
{
    kAudioTimeStampSampleHostTimeValid  = (kAudioTimeStampSampleTimeValid | kAudioTimeStampHostTimeValid)
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Combinations of AudioTimeStamp Flags
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kAudioTimeStampSampleHostTimeValid"><tt>kAudioTimeStampSampleHostTimeValid</tt></a></dt><dd>The sample frame time and the host time are valid.</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/Format"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Format">Format</a></h2>
</td></tr></table><hr>The four char code IDs used to identify individual formats of audio data.
<br>
<blockquote><pre>
enum
{
    kAudioFormatLinearPCM               = 'lpcm',
    kAudioFormatAC3                     = 'ac-3',
    kAudioFormat60958AC3                = 'cac3',
    kAudioFormatAppleIMA4               = 'ima4',
    kAudioFormatMPEG4AAC                = 'aac ',
    kAudioFormatMPEG4CELP               = 'celp',
    kAudioFormatMPEG4HVXC               = 'hvxc',
    kAudioFormatMPEG4TwinVQ             = 'twvq',
    kAudioFormatMACE3                   = 'MAC3',
    kAudioFormatMACE6                   = 'MAC6',
    kAudioFormatULaw                    = 'ulaw',
    kAudioFormatALaw                    = 'alaw',
    kAudioFormatQDesign                 = 'QDMC',
    kAudioFormatQDesign2                = 'QDM2',
    kAudioFormatQUALCOMM                = 'Qclp',
    kAudioFormatMPEGLayer1              = '.mp1',
    kAudioFormatMPEGLayer2              = '.mp2',
    kAudioFormatMPEGLayer3              = '.mp3',
    kAudioFormatDVAudio                 = 'dvca',
    kAudioFormatVariableDurationDVAudio = 'vdva',
    kAudioFormatTimeCode                = 'time',
    kAudioFormatMIDIStream              = 'midi',
    kAudioFormatParameterValueStream    = 'apvs',
    kAudioFormatAppleLossless           = 'alac'
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>IDs
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kAudioFormatLinearPCM"><tt>kAudioFormatLinearPCM</tt></a></dt><dd>Linear PCM, uses the standard flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatAC3"><tt>kAudioFormatAC3</tt></a></dt><dd>AC-3, has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormat60958AC3"><tt>kAudioFormat60958AC3</tt></a></dt><dd>AC-3 packaged for transport over an IEC 60958 compliant digital audio
interface. Uses the standard flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatAppleIMA4"><tt>kAudioFormatAppleIMA4</tt></a></dt><dd>Apples implementation of IMA 4:1 ADPCM, has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMPEG4AAC"><tt>kAudioFormatMPEG4AAC</tt></a></dt><dd>MPEG-4 AAC, the flags field contains the MPEG-4 audio object type constant
indicating the specific kind of data.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMPEG4CELP"><tt>kAudioFormatMPEG4CELP</tt></a></dt><dd>MPEG-4 CELP, the flags field contains the MPEG-4 audio object type constant
indicating the specific kind of data.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMPEG4HVXC"><tt>kAudioFormatMPEG4HVXC</tt></a></dt><dd>MPEG-4 HVXC, the flags field contains the MPEG-4 audio object type constant
indicating the specific kind of data.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMPEG4TwinVQ"><tt>kAudioFormatMPEG4TwinVQ</tt></a></dt><dd>MPEG-4 TwinVQ, the flags field contains the MPEG-4 audio object type
constant indicating the specific kind of data.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMACE3"><tt>kAudioFormatMACE3</tt></a></dt><dd>MACE 3:1, has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMACE6"><tt>kAudioFormatMACE6</tt></a></dt><dd>MACE 6:1, has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatULaw"><tt>kAudioFormatULaw</tt></a></dt><dd>µLaw 2:1, has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatALaw"><tt>kAudioFormatALaw</tt></a></dt><dd>aLaw 2:1, has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatQDesign"><tt>kAudioFormatQDesign</tt></a></dt><dd>QDesign music, has no flags</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatQDesign2"><tt>kAudioFormatQDesign2</tt></a></dt><dd>QDesign2 music, has no flags</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatQUALCOMM"><tt>kAudioFormatQUALCOMM</tt></a></dt><dd>QUALCOMM PureVoice, has no flags</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMPEGLayer1"><tt>kAudioFormatMPEGLayer1</tt></a></dt><dd>MPEG-1/2, Layer 1 audio, has no flags</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMPEGLayer2"><tt>kAudioFormatMPEGLayer2</tt></a></dt><dd>MPEG-1/2, Layer 2 audio, has no flags</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMPEGLayer3"><tt>kAudioFormatMPEGLayer3</tt></a></dt><dd>MPEG-1/2, Layer 3 audio, has no flags</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatDVAudio"><tt>kAudioFormatDVAudio</tt></a></dt><dd>DV Audio, has no flags</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatVariableDurationDVAudio"><tt>kAudioFormatVariableDurationDVAudio</tt></a></dt><dd>Variable duration DV Audio, has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatTimeCode"><tt>kAudioFormatTimeCode</tt></a></dt><dd>A stream of IOAudioTimeStamps, uses the IOAudioTimeStamp flags (see
IOKit/audio/IOAudioTypes.h).</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatMIDIStream"><tt>kAudioFormatMIDIStream</tt></a></dt><dd>A stream of MIDIPacketLists where the time stamps in the MIDIPacketList are
sample offsets in the stream. The mSampleRate field is used to describe how
time is passed in this kind of stream and an AudioUnit that receives or
generates this stream can use this sample rate, the number of frames it is
rendering and the sample offsets within the MIDIPacketList to define the
time for any MIDI event within this list. It has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatParameterValueStream"><tt>kAudioFormatParameterValueStream</tt></a></dt><dd>A "side-chain" of Float32 data that can be fed or generated by an AudioUnit
and is used to send a high density of parameter value control information.
An AU will typically run a ParameterValueStream at either the sample rate of
the AudioUnit's audio data, or some integer divisor of this (say a half or a
third of the sample rate of the audio). The Sample Rate of the ASBD
describes this relationship. It has no flags.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatAppleLossless"><tt>kAudioFormatAppleLossless</tt></a></dt><dd>Apple Lossless, has no flags.</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/MPEG-4 Audio Object IDs"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="MPEG-4 Audio Object IDs">MPEG-4 Audio Object IDs</a></h2>
</td></tr></table><hr>Constants that describe the various kinds of MPEG-4 audio data.
<br>
<blockquote><pre>
enum
{
    kMPEG4Object_AAC_Main       = 1,
    kMPEG4Object_AAC_LC         = 2,
    kMPEG4Object_AAC_SSR        = 3,
    kMPEG4Object_AAC_LTP        = 4,
    kMPEG4Object_AAC_SBR        = 5,
    kMPEG4Object_AAC_Scalable   = 6,
    
    kMPEG4Object_TwinVQ         = 7,
    kMPEG4Object_CELP           = 8,
    kMPEG4Object_HVXC           = 9
    
};    
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>These constants are used in the flags field of an AudioStreamBasicDescription
that describes an MPEG-4 audio stream.
</p>
<hr><a name="//apple_ref/c/tag/SMPTE"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="SMPTE">SMPTE</a></h2>
</td></tr></table><hr>Constants that describe the type of SMPTE time.
<br>
<blockquote><pre>
enum
{
    kSMPTETimeType24        = 0,
    kSMPTETimeType25        = 1,
    kSMPTETimeType30Drop    = 2,
    kSMPTETimeType30        = 3,
    kSMPTETimeType2997      = 4,
    kSMPTETimeType2997Drop  = 5,
    kSMPTETimeType60        = 6,
    kSMPTETimeType5994      = 7
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Time Types
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kSMPTETimeType24"><tt>kSMPTETimeType24</tt></a></dt><dd>24 Frame</dd>
<dt><a name="//apple_ref/c/econst/kSMPTETimeType25"><tt>kSMPTETimeType25</tt></a></dt><dd>25 Frame</dd>
<dt><a name="//apple_ref/c/econst/kSMPTETimeType30Drop"><tt>kSMPTETimeType30Drop</tt></a></dt><dd>30 Drop Frame</dd>
<dt><a name="//apple_ref/c/econst/kSMPTETimeType30"><tt>kSMPTETimeType30</tt></a></dt><dd>30 Frame</dd>
<dt><a name="//apple_ref/c/econst/kSMPTETimeType2997"><tt>kSMPTETimeType2997</tt></a></dt><dd>29.97 Frame</dd>
<dt><a name="//apple_ref/c/econst/kSMPTETimeType2997Drop"><tt>kSMPTETimeType2997Drop</tt></a></dt><dd>29.97 Drop Frame</dd>
<dt><a name="//apple_ref/c/econst/kSMPTETimeType60"><tt>kSMPTETimeType60</tt></a></dt><dd>60 Frame</dd>
<dt><a name="//apple_ref/c/econst/kSMPTETimeType5994"><tt>kSMPTETimeType5994</tt></a></dt><dd>59.94 Frame</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/SMPTE"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="SMPTE">SMPTE</a></h2>
</td></tr></table><hr>Flags that describe the SMPTE time state.
<br>
<blockquote><pre>
enum
{
    kSMPTETimeValid     = (1L &lt;&lt; 0),
    kSMPTETimeRunning   = (1L &lt;&lt; 1)
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>State Flags
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kSMPTETimeValid"><tt>kSMPTETimeValid</tt></a></dt><dd>The full time is valid.</dd>
<dt><a name="//apple_ref/c/econst/kSMPTETimeRunning"><tt>kSMPTETimeRunning</tt></a></dt><dd>Time is running.</dd>
</dl>
</blockquote>
<hr><a name="//apple_ref/c/tag/Standard Flag Values for AudioStreamBasicDescription"></a>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="Standard Flag Values for AudioStreamBasicDescription">Standard Flag Values for AudioStreamBasicDescription</a></h2>
</td></tr></table><hr>These are the standard flags for use in the mFormatFlags field of the
AudioStreamBasicDescription structure.
<br>
<blockquote><pre>
enum
{
    kAudioFormatFlagIsFloat                     = (1L &lt;&lt; 0),
    kAudioFormatFlagIsBigEndian                 = (1L &lt;&lt; 1),
    kAudioFormatFlagIsSignedInteger             = (1L &lt;&lt; 2),
    kAudioFormatFlagIsPacked                    = (1L &lt;&lt; 3),
    kAudioFormatFlagIsAlignedHigh               = (1L &lt;&lt; 4),
    kAudioFormatFlagIsNonInterleaved            = (1L &lt;&lt; 5),
    kAudioFormatFlagIsNonMixable                = (1L &lt;&lt; 6),
    kAudioFormatFlagsAreAllClear                = (1L &lt;&lt; 31),
    
    kLinearPCMFormatFlagIsFloat                 = kAudioFormatFlagIsFloat,
    kLinearPCMFormatFlagIsBigEndian             = kAudioFormatFlagIsBigEndian,
    kLinearPCMFormatFlagIsSignedInteger         = kAudioFormatFlagIsSignedInteger,
    kLinearPCMFormatFlagIsPacked                = kAudioFormatFlagIsPacked,
    kLinearPCMFormatFlagIsAlignedHigh           = kAudioFormatFlagIsAlignedHigh,
    kLinearPCMFormatFlagIsNonInterleaved        = kAudioFormatFlagIsNonInterleaved,
    kLinearPCMFormatFlagIsNonMixable            = kAudioFormatFlagIsNonMixable,
    kLinearPCMFormatFlagsAreAllClear            = kAudioFormatFlagsAreAllClear,
    
    kAppleLosslessFormatFlag_16BitSourceData    = 1,
    kAppleLosslessFormatFlag_20BitSourceData    = 2,
    kAppleLosslessFormatFlag_24BitSourceData    = 3,
    kAppleLosslessFormatFlag_32BitSourceData    = 4
};
</pre>
</blockquote>
<h5><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5><p>Typically, when an ASBD is being used, the fields describe the complete layout
of the sample data in the buffers that are represented by this description -
where typically those buffers are represented by an AudioBuffer that is
contained in an AudioBufferList.
<br><br>
However, when an ASBD has the kAudioFormatFlagIsNonInterleaved flag, the
AudioBufferList has a different structure and semantic. In this case, the ASBD
fields will describe the format of ONE of the AudioBuffers that are contained in
the list, AND each AudioBuffer in the list is determined to have a single (mono)
channel of audio data. Then, the ASBD's mChannelsPerFrame will indicate the
total number of AudioBuffers that are contained within the AudioBufferList -
where each buffer contains one channel. This is used primarily with the
AudioUnit (and AudioConverter) representation of this list - and won't be found
in the AudioHardware usage of this structure.
</p>
<h4>Constants</h4>
<blockquote>
<dl>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagIsFloat"><tt>kAudioFormatFlagIsFloat</tt></a></dt><dd>Set for floating point, clear for integer.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagIsBigEndian"><tt>kAudioFormatFlagIsBigEndian</tt></a></dt><dd>Set for big endian, clear for little endian.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagIsSignedInteger"><tt>kAudioFormatFlagIsSignedInteger</tt></a></dt><dd>Set for signed integer, clear for unsigned integer. This is only valid if
kAudioFormatFlagIsFloat is clear.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagIsPacked"><tt>kAudioFormatFlagIsPacked</tt></a></dt><dd>Set if the sample bits occupy the entire available bits for the channel,
clear if they are high or low aligned within the channel.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagIsAlignedHigh"><tt>kAudioFormatFlagIsAlignedHigh</tt></a></dt><dd>Set if the sample bits are placed into the high bits of the channel, clear
for low bit placement. This is only valid if kAudioFormatFlagIsPacked is
clear.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagIsNonInterleaved"><tt>kAudioFormatFlagIsNonInterleaved</tt></a></dt><dd>Set if the samples for each channel are located contiguously and the
channels are layed out end to end, clear if the samples for each frame are
layed out contiguously and the frames layed out end to end.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagIsNonMixable"><tt>kAudioFormatFlagIsNonMixable</tt></a></dt><dd>Set to indicate when a format is non-mixable. Note that this flag is only
used when interacting with the HAL's stream format information. It is not a
valid flag for any other uses.</dd>
<dt><a name="//apple_ref/c/econst/kAudioFormatFlagsAreAllClear"><tt>kAudioFormatFlagsAreAllClear</tt></a></dt><dd>Set if all the flags would be clear in order to preserve 0 as the wild card
value.</dd>
<dt><a name="//apple_ref/c/econst/kLinearPCMFormatFlagIsFloat"><tt>kLinearPCMFormatFlagIsFloat</tt></a></dt><dd>Synonym for kAudioFormatFlagIsFloat.</dd>
<dt><a name="//apple_ref/c/econst/kLinearPCMFormatFlagIsBigEndian"><tt>kLinearPCMFormatFlagIsBigEndian</tt></a></dt><dd>Synonym for kAudioFormatFlagIsBigEndian.</dd>
<dt><a name="//apple_ref/c/econst/kLinearPCMFormatFlagIsSignedInteger"><tt>kLinearPCMFormatFlagIsSignedInteger</tt></a></dt><dd>Synonym for kAudioFormatFlagIsSignedInteger.</dd>
<dt><a name="//apple_ref/c/econst/kLinearPCMFormatFlagIsPacked"><tt>kLinearPCMFormatFlagIsPacked</tt></a></dt><dd>Synonym for kAudioFormatFlagIsPacked.</dd>
<dt><a name="//apple_ref/c/econst/kLinearPCMFormatFlagIsAlignedHigh"><tt>kLinearPCMFormatFlagIsAlignedHigh</tt></a></dt><dd>Synonym for kAudioFormatFlagIsAlignedHigh.</dd>
<dt><a name="//apple_ref/c/econst/kLinearPCMFormatFlagIsNonInterleaved"><tt>kLinearPCMFormatFlagIsNonInterleaved</tt></a></dt><dd>Synonym for kAudioFormatFlagIsNonInterleaved.</dd>
<dt><a name="//apple_ref/c/econst/kLinearPCMFormatFlagIsNonMixable"><tt>kLinearPCMFormatFlagIsNonMixable</tt></a></dt><dd>Synonym for kAudioFormatFlagIsNonMixable.</dd>
<dt><a name="//apple_ref/c/econst/kLinearPCMFormatFlagsAreAllClear"><tt>kLinearPCMFormatFlagsAreAllClear</tt></a></dt><dd>Synonym for kAudioFormatFlagsAreAllClear.</dd>
<dt><a name="//apple_ref/c/econst/kAppleLosslessFormatFlag_16BitSourceData"><tt>kAppleLosslessFormatFlag_16BitSourceData</tt></a></dt><dd>This flag is set for Apple Lossless data that was sourced from 16 bit native
endian signed integer data.</dd>
<dt><a name="//apple_ref/c/econst/kAppleLosslessFormatFlag_20BitSourceData"><tt>kAppleLosslessFormatFlag_20BitSourceData</tt></a></dt><dd>This flag is set for Apple Lossless data that was sourced from 20 bit native
endian signed integer data aligned high in 24 bits.</dd>
<dt><a name="//apple_ref/c/econst/kAppleLosslessFormatFlag_24BitSourceData"><tt>kAppleLosslessFormatFlag_24BitSourceData</tt></a></dt><dd>This flag is set for Apple Lossless data that was sourced from 24 bit native
endian signed integer data.</dd>
<dt><a name="//apple_ref/c/econst/kAppleLosslessFormatFlag_32BitSourceData"><tt>kAppleLosslessFormatFlag_32BitSourceData</tt></a></dt><dd>This flag is set for Apple Lossless data that was sourced from 32 bit native
endian signed integer data.</dd>
</dl>
</blockquote>
<h2>#defines</h2>
<hr>
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5"><h2><a name="TestAudioFormatNativeEndian">TestAudioFormatNativeEndian</a></h2>
</td></tr></table><hr>A macro for checking if an ASBD indicates native endian linear PCM data.<br>
<blockquote><pre>
#define TestAudioFormatNativeEndian(f)  ((f.mFormatID == kAudioFormatLinearPCM) && ((f.mFormatFlags & kAudioFormatFlagIsBigEndian) == kAudioFormatFlagsNativeEndian))
</pre>
</blockquote>
<p>(Last Updated 12/13/2004)
</p></body></html>
